snippet fio "fast i/o"
ios_base::sync_with_stdio(0);
cin.tie(0);cout.tie(0);
endsnippet

snippet file "inputoutput"
freopen("ip.txt","r",stdin);
freopen("op.txt","w",stdout);
endsnippet

snippet neet "simple&clean"
#include "bits/stdc++.h"
using namespace std;

#define int long long
const int MOD = 1e9+7;
const int INF = 0x3F3F3F3F3F3F3F3F;

signed main()
{
    $1
}
endsnippet


snippet hekk "extensive"
#include "bits/stdc++.h"
// #include<ext/pb_ds/assoc_container.hpp>
// #include<ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
using namespace std;
#define ld           long double
#define vi           vector<int>
#define pii          pair<int,int>
#define pb           push_back
#define mp           make_pair
#define ff           first
#define ss           second
#define endl         '\n'
#define rep(i,s,e)   for(int i=(s);i<=(e);i++)
#define brep(i,s,e)  for(int i=(s);i>=(e);i--)
#define _T           int T;cin>>T;rep(TT,1,T)
#define all(x)       (x).begin(),(x).end()
#define ball(x)      (x).rbegin(),(x).rend()
#define sz(x)        (int)x.size()
#define mem(x,y)     memset(x,(char)y,sizeof(x))
#define milf(x)      x.reserve(1LL<<14LL); x.max_load_factor(0.25); // less_equal
#define pbds         tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
mt19937              rng(chrono::steady_clock::now().time_since_epoch().count());
#define int          long long
const int INF = 0x3F3F3F3F3F3F3F3F;
const int MOD = 1e9+7;
ld EPS = 1e-12;


int _main()
{
    // _T
    {
        $1
    }

    return 0;
}

signed main()
{
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    // freopen("ip.txt","r",stdin);
    // freopen("op.txt","w",stdout);

    int tt = 1000*clock()/CLOCKS_PER_SEC;

    cout<<fixed<<setprecision(15);_main();

    cerr<<1000*clock()/CLOCKS_PER_SEC-tt<<"ms\n";
}
endsnippet


snippet bojack "bojack"
/*
  "Piece of shit. Stupid piece of shit. I'm a real stupid piece
   of shit. But I know I'm a piece of shit. That at least makes
   me better than all the pieces of shit that don't know they're
   pieces of shit. Or is it worse?"
     - BoJack F. Horseman
*/
#include "bits/stdc++.h"
// #include<ext/pb_ds/assoc_container.hpp>
// #include<ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
using namespace std;
#define ld           long double
#define vi           vector<int>
#define pii          pair<int,int>
#define pb           push_back
#define mp           make_pair
#define ff           first
#define ss           second
#define endl         '\n'
#define rep(i,s,e)   for(int i=(s);i<=(e);i++)
#define brep(i,s,e)  for(int i=(s);i>=(e);i--)
#define all(x)       (x).begin(),(x).end()
#define ball(x)      (x).rbegin(),(x).rend()
#define sz(x)        (int)x.size()
#define mem(x,y)     memset(x,(char)y,sizeof(x))
#define milf(x)      x.reserve(1LL<<14LL); x.max_load_factor(0.25); // less_equal
#define pbds         tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
mt19937              rng(chrono::steady_clock::now().time_since_epoch().count());
#define int          long long
const int INF = 0x3F3F3F3F3F3F3F3F;
const int MOD = 1e9+7;
ld EPS = 1e-12;


short rain()
{
    // ifstream fin("ip.txt"); ofstream fout("op.txt");
    // int T;cin>>T;rep(TT,1,T)
    {
        $1
    }

    return 0;
}

signed main()
{
	// when getting input using getline(cin,s)
	// after getting input from cin >> n, best to use
	// cin.ignore( 1, '\n' );
	// Because problem occurs that getline ignores the first
	// input. This is due to getting the "enter" from cin
	// and hence getting nothing for first input. This
	// statement eats up the "enter" input to avoid the problemo.
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int start = 1000*clock()/CLOCKS_PER_SEC;
    cout << fixed << setprecision(15);           rain();
    cerr << 1000*clock()/CLOCKS_PER_SEC-start << "ms\n";
    // *( hsh.find_by_order(k) )               kth smallest, from 0
    // hsh.order_of_key(k)                     num of ele str less than k
    // change less to less_equal for multiset pbds
    // if we have a erase operation, use less with pair<int,int>
    // hsh.erase( hsh.lower_bound({x,0}) )     erases an instance of x
    // hsh.find_by_order(k)->first             element at index k
    // hsh.order_of_key( {x,0} )               first index of x
    // Create struct HASH; Use milf(x) for every hashmap; Use CRNG xor;
}
endsnippet


snippet dsu "Disjoint-Set Union"
class DSU
{
    private:
        int par[(int)(1e5+5)];

    public:

        int parentOf(int x)
        {
            if( par[x]<0 )
                return x;
            return par[x] = parentOf( par[x] );
        }

        void unite(int x, int y)
        {
            int pX = parentOf(x);
            int pY = parentOf(y);
            if( pX==pY )
                return;
            if( abs(par[pX]) < abs(par[pY]) )
                swap( pX, pY );
            par[pX] += par[pY];
            par[pY] = pX;
        }

        DSU()
        {
            memset( par, -1, sizeof(par) );
        }
}
endsnippet


snippet modexp "Modular Exponention"
int modexp(int base, int exp)
{
    int res = 1;
    while( exp>0 )
    {
        if( exp&(int)1 ) res *= base, res %= MOD;
        base *= base, base %= MOD, exp >>= (int)1;
    }
    return res;
}
endsnippet


snippet modinv "Extended Euclidean Algorithm"
// Extended Euclidean Algorithm ax + by = gcd(a,b)
// returns gcd and stores x and y
int exgcd(int a, int b, int &x, int &y)
{
    int g = a; x = 1, y = 0;
    if( b ) g = exgcd( b,a%b,y,x ), y -= (a/b)*x;
    return g;
}

// Modular Multiplicative Inverse of a (mod m)
int modinv(int a, int m)
{
    int x, y;
    exgcd( a,m,x,y );
    return ( x+m )%m;
}
endsnippet


snippet sieve "Sieve of Eratosthenes"
const int PRIMES = 1e7+6;
vector<int> prime;
vector<int> comp;
bool isp[PRIMES];
void sieve(int n = PRIMES)
{
    memset( isp, true, sizeof(isp) );
    isp[0] = isp[1] = false;
    for(int j=4; j<n; j+=2)
        isp[j] = false;
    for(int i=3; i*i<n; i+=2)
    {
        if( !isp[i] )
            continue;
        for(int j=i*i; j<n; j+=i)
            isp[j] = false;
    }
    // for(int i=2; i<n; i++)
    //     isp[i] ? prime.push_back(i) : comp.push_back(i);
}
endsnippet


snippet prime "Prime Factorization"
vector<int> pfac;
void primefac(int n)
{
    for(int i=2; i*i<=n; i++)
    {
        if( n%i != 0 ) continue;
        pfac.push_back( i );
        while( n%i==0 ) n/=i;
    }
    if( n>1 ) pfac.push_back( n );
}
endsnippet


snippet fac "Factorization"
vector<int> fac;
void factorize(int n)
{
    for(int i=1; i*i<=n; i++)
    {
        if( n%i != 0 ) continue;
        fac.push_back( i );
        if( i*i != n )
        fac.push_back( n/i );
    }
}
endsnippet


snippet milf "Hash Structure"
struct HASH
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += UINT64_C(0x9e3779b97f4a7c15);
        x = (x ^ (x >> 30)) * UINT64_C(0xbf58476d1ce4e5b9);
        x = (x ^ (x >> 27)) * UINT64_C(0x94d049bb133111eb);
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const
    {  return splitmix64( x+crng );  }
};
endsnippet

snippet segment "Segment Tree"
class segTree
{
    private:
        int n;
        vector<int> tree;

        void make(int v, int l, int r, vector<int> &a)
        {
            if( l==r )
            {
                tree[v] = a[l];
                return;
            }
            int m = (l+r)>>1;
            make( 2*v, l, m, a );
            make( 2*v+1, m+1, r, a );
            tree[v] = max( tree[2*v], tree[2*v+1] );
        }

        int query(int v, int l, int r, int ql, int qr)
        {
            if( ql>qr )
                return INT_MIN;

            if( l==ql && r==qr )
                return tree[v];

            int m = (l+r)>>1;
            int leftAns = query( 2*v, l, m, ql, min(m,qr) );
            int rightAns = query( 2*v+1, m+1, r, max(ql,m+1), qr );
            return max( leftAns, rightAns );
        }

        void update(int v, int l, int r, int idx, int val)
        {
            if( l==r )
            {
                tree[v] = val;
                return;
            }
            int m = (l+r)>>1;
            if( idx>m )
                update( 2*v+1, m+1, r, idx, val );
            else
                update( 2*v, l, m, idx, val );
            tree[v] = max( tree[2*v], tree[2*v+1] );
        }

    public:

        int queryRange(int l, int r)
        {
            return query( 1, 0, n-1, l, r );
        }

        void updateIndex(int index, int value)
        {
            update( 1, 0, n-1, index, value );
        }

        segTree(vector<int> &a)
        {
            this->n = a.size();
            this->tree.resize( 4*n );
            this->make( 1, 0, n-1, a );
        }
};
endsnippet

snippet kmp "KMP String Matching"
vector<int> stringMatch(string &s, string &pat)
{
    string t = pat + "#" + s;
    int n = t.length();
    int pi[n];
    pi[0] = 0;
    for(int i=1; i<n; i++)
    {
        int j = pi[i-1];
        while( j>0 && t[i]!=t[j] )
            j = pi[j-1];
        if( t[i]==t[j] )
            j++;
        pi[i] = j;
    }
    vector<int> occ;
    for(int i=0; i<n; i++)
    {
        if( pi[i]==(int)(pat.length()) )
            occ.push_back( i - (int)(s.length()) - 1 );
    }
    return occ;
}
endsnippet
